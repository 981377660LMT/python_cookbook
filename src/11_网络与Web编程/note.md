关于 requests 库，一个值得一提的特性就是它能以多种方式从请求中返回响应结果的内容。从上面的代码来看， resp.text 带给我们的是以 Unicode 解码的响应文本。但是，如果去访问 resp.content ，就会得到原始的二进制数据。另一方面，如果访问 resp.json ，那么就会得到 JSON 格式的响应内容。

绝大部分 Python 的高层网络模块（比如 HTTP、XML-RPC 等）都是建立在 socketserver 功能之上
HTTP 通信通常通过 TCP/IP 连接进行。
HTTP 是一个应用层协议，可以用使用 UDP 的协议进行封装，从而提供比 TCP 更快的可靠通信。
不过通常来说，如果可靠性对于你程序很重要，你需要借助于**序列号、重试、超时**以及一些其他方法来保证。
UDP 通常被用在那些对于可靠传输要求不是很高的场合。例如，在实时应用如多媒体流以及游戏领域， 无需返回恢复丢失的数据包（程序只需简单的忽略它并继续向前运行）。

TCP/UDP 客户端都是由以下

```Python
s = socket(AF_INET, SOCK_DGRAM) 创建
但是TCP有连接步骤 s.connect(('localhost', 20000)) 而UDP没有
```

实现一个简单的 REST 接口，你只需让你的程序代码满足 Python 的 WSGI 标准即可

**hmac**
你想在分布式系统中实现一个简单的客户端连接认证功能，又不想像 SSL 那样的复杂
基本原理是当连接建立后，服务器给客户端发送一个随机的字节消息（这里例子中使用了 os.urandom() 返回值）。 客户端和服务器同时利用 hmac 和一个只有双方知道的密钥来计算出一个加密哈希值。然后客户端将它计算出的摘要发送给服务器， 服务器通过比较这个值和自己计算的是否一致来决定接受或拒绝连接。
摘要的比较需要使用 hmac.compare_digest() 函数。 使用这个函数可以避免遭到时间分析攻击，不要用简单的比较操作符（==）。

你想实现一个基于 sockets 的网络服务，客户端和服务器通过 SSL 协议认证并加密传输的数据。
...

在数据密集型分布式计算和平行计算程序中，自己写程序来实现发送/接受大量数据并不常见。 不过，要是你确实想这样做，你可能需要将你的数据转换成原始字节，以便给低层的网络函数使用。 你可能还需要将数据切割成多个块，因为大部分和网络相关的函数并不能一次性发送或接受超大数据块。
